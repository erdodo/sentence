var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
export function FormControlMixin(SuperClass) {
    var _FormControl_instances, _FormControl_focused, _FormControl_forceError, _FormControl_touched, _FormControl_abortController, _FormControl_previousAbortController, _FormControl_awaitingValidationTarget, _FormControl_formValidationGroup_get, _FormControl_value, _FormControl_onFocus, _FormControl_onBlur, _FormControl_onInvalid, _FormControl_validationCompleteResolver, _FormControl_isValidationPending, _FormControl_validationComplete, _FormControl_shouldShowError, _FormControl_runValidators, _FormControl_setValidityWithOptionalTarget, _FormControl_getValidatorMessageForValue;
    class FormControl extends SuperClass {
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        constructor(...args) {
            var _a, _b, _c;
            super(...args);
            _FormControl_instances.add(this);
            /** The ElementInternals instance for the control. */
            this.internals = this.attachInternals();
            /**
             * Keep track of if the control has focus
             * @private
             */
            _FormControl_focused.set(this, false);
            /**
             * Exists to control when an error should be displayed
             * @private
             */
            _FormControl_forceError.set(this, false);
            /**
             * Toggles to true whenever the element has been focused. This property
             * will reset whenever the control's formResetCallback is called.
             * @private
             */
            _FormControl_touched.set(this, false);
            /** An internal abort controller for cancelling pending async validation */
            _FormControl_abortController.set(this, void 0);
            _FormControl_previousAbortController.set(this, void 0);
            /**
             * Used for tracking if a validation target has been set to manage focus
             * when the control's validity is reported
             */
            _FormControl_awaitingValidationTarget.set(this, true);
            /**
             * Acts as a cache for the current value so the value can be re-evaluated
             * whenever an attribute changes or on some other event.
             */
            _FormControl_value.set(this, '');
            /**
             * Set this[touched] and this[focused]
             * to true when the element is focused
             * @private
             */
            _FormControl_onFocus.set(this, () => {
                __classPrivateFieldSet(this, _FormControl_touched, true, "f");
                __classPrivateFieldSet(this, _FormControl_focused, true, "f");
                __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_shouldShowError).call(this);
            });
            /**
             * Reset this[focused] on blur
             * @private
             */
            _FormControl_onBlur.set(this, () => {
                __classPrivateFieldSet(this, _FormControl_focused, false, "f");
                __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_runValidators).call(this, this.shouldFormValueUpdate() ? __classPrivateFieldGet(this, _FormControl_value, "f") : '');
                /**
                 * Set forceError to ensure error messages persist until
                 * the value is changed.
                 */
                if (!this.validity.valid && __classPrivateFieldGet(this, _FormControl_touched, "f")) {
                    __classPrivateFieldSet(this, _FormControl_forceError, true, "f");
                }
                const showError = __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_shouldShowError).call(this);
                if (this.validationMessageCallback) {
                    this.validationMessageCallback(showError ? this.internals.validationMessage : '');
                }
            });
            /**
             * For the show error state on invalid
             * @private
             */
            _FormControl_onInvalid.set(this, () => {
                var _a;
                if (__classPrivateFieldGet(this, _FormControl_awaitingValidationTarget, "f") && this.validationTarget) {
                    this.internals.setValidity(this.validity, this.validationMessage, this.validationTarget);
                    __classPrivateFieldSet(this, _FormControl_awaitingValidationTarget, false, "f");
                }
                __classPrivateFieldSet(this, _FormControl_touched, true, "f");
                __classPrivateFieldSet(this, _FormControl_forceError, true, "f");
                __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_shouldShowError).call(this);
                (_a = this === null || this === void 0 ? void 0 : this.validationMessageCallback) === null || _a === void 0 ? void 0 : _a.call(this, this.showError ? this.internals.validationMessage : '');
            });
            /** Save a reference to the validation complete resolver */
            _FormControl_validationCompleteResolver.set(this, void 0);
            /** When true validation will be pending */
            _FormControl_isValidationPending.set(this, false);
            _FormControl_validationComplete.set(this, Promise.resolve());
            (_a = this.addEventListener) === null || _a === void 0 ? void 0 : _a.call(this, 'focus', __classPrivateFieldGet(this, _FormControl_onFocus, "f"));
            (_b = this.addEventListener) === null || _b === void 0 ? void 0 : _b.call(this, 'blur', __classPrivateFieldGet(this, _FormControl_onBlur, "f"));
            (_c = this.addEventListener) === null || _c === void 0 ? void 0 : _c.call(this, 'invalid', __classPrivateFieldGet(this, _FormControl_onInvalid, "f"));
            this.setValue(null);
        }
        /** Wires up control instances to be form associated */
        static get formAssociated() {
            return true;
        }
        static get validators() {
            return this.formControlValidators || [];
        }
        /**
         * Allows the FormControl instance to respond to Validator attributes.
         * For instance, if a given Validator has a `required` attribute, that
         * validator will be evaluated whenever the host's required attribute
         * is updated.
         */
        static get observedAttributes() {
            const validatorAttributes = this.validators.map((validator) => validator.attribute).flat();
            const observedAttributes = super.observedAttributes || [];
            /** Make sure there are no duplicates inside the attributes list */
            const attributeSet = new Set([...observedAttributes, ...validatorAttributes]);
            return [...attributeSet];
        }
        /**
         * Return the validator associated with a given attribute. If no
         * Validator is associated with the attribute, it will return null.
         */
        static getValidator(attribute) {
            return this.validators.find((validator) => validator.attribute === attribute) || null;
        }
        /**
         * Get all validators that are set to react to a given attribute
         * @param {string} attribute - The attribute that has changed
         * @returns {Validator[]}
         */
        static getValidators(attribute) {
            return this.validators.filter(validator => {
                var _a;
                if (validator.attribute === attribute || ((_a = validator.attribute) === null || _a === void 0 ? void 0 : _a.includes(attribute))) {
                    return true;
                }
            });
        }
        /** Return a reference to the control's form */
        get form() {
            return this.internals.form;
        }
        /**
         * Will return true if it is recommended that the control shows an internal
         * error. If using this property, it is wise to listen for 'invalid' events
         * on the element host and call preventDefault on the event. Doing this will
         * prevent browsers from showing a validation popup.
         */
        get showError() {
            return __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_shouldShowError).call(this);
        }
        /**
         * Forward the internals checkValidity method
         * will return the valid state of the control.
         */
        checkValidity() {
            return this.internals.checkValidity();
        }
        /** The element's validity state */
        get validity() {
            return this.internals.validity;
        }
        /**
         * The validation message shown by a given Validator object. If the control
         * is in a valid state this should be falsy.
         */
        get validationMessage() {
            return this.internals.validationMessage;
        }
        attributeChangedCallback(name, oldValue, newValue) {
            var _a;
            (_a = super.attributeChangedCallback) === null || _a === void 0 ? void 0 : _a.call(this, name, oldValue, newValue);
            /**
             * Check to see if a Validator is associated with the changed attribute.
             * If one exists, call control's validate function which will perform
             * control validation.
             */
            const proto = this.constructor;
            const validators = proto.getValidators(name);
            if ((validators === null || validators === void 0 ? void 0 : validators.length) && this.validationTarget) {
                this.setValue(__classPrivateFieldGet(this, _FormControl_value, "f"));
            }
        }
        /** PUBLIC LIFECYCLE METHODS */
        /**
         * Sets the control's form value if the call to `shouldFormValueUpdate`
         * returns `true`.
         * @param value {FormValue} - The value to pass to the form
         */
        setValue(value) {
            var _a;
            __classPrivateFieldSet(this, _FormControl_forceError, false, "f");
            (_a = this.validationMessageCallback) === null || _a === void 0 ? void 0 : _a.call(this, '');
            __classPrivateFieldSet(this, _FormControl_value, value, "f");
            const valueShouldUpdate = this.shouldFormValueUpdate();
            const valueToUpdate = valueShouldUpdate ? value : null;
            this.internals.setFormValue(valueToUpdate);
            __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_runValidators).call(this, valueToUpdate);
            if (this.valueChangedCallback) {
                this.valueChangedCallback(valueToUpdate);
            }
            __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_shouldShowError).call(this);
        }
        /**
         * This method can be overridden to determine if the control's form value
         * should be set on a call to `setValue`. An example of when a user might want
         * to skip this step is when implementing checkbox-like behavior, first checking
         * to see if `this.checked` is set to a truthy value. By default this returns
         * `true`.
         */
        shouldFormValueUpdate() {
            return true;
        }
        /** A promise that will resolve when all pending validations are complete */
        get validationComplete() {
            return new Promise(resolve => resolve(__classPrivateFieldGet(this, _FormControl_validationComplete, "f")));
        }
        /** Reset control state when the form is reset */
        formResetCallback() {
            var _a, _b;
            __classPrivateFieldSet(this, _FormControl_touched, false, "f");
            __classPrivateFieldSet(this, _FormControl_forceError, false, "f");
            __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_shouldShowError).call(this);
            (_a = this.resetFormControl) === null || _a === void 0 ? void 0 : _a.call(this);
            (_b = this.validationMessageCallback) === null || _b === void 0 ? void 0 : _b.call(this, __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_shouldShowError).call(this) ? this.validationMessage : '');
        }
    }
    _FormControl_focused = new WeakMap(), _FormControl_forceError = new WeakMap(), _FormControl_touched = new WeakMap(), _FormControl_abortController = new WeakMap(), _FormControl_previousAbortController = new WeakMap(), _FormControl_awaitingValidationTarget = new WeakMap(), _FormControl_value = new WeakMap(), _FormControl_onFocus = new WeakMap(), _FormControl_onBlur = new WeakMap(), _FormControl_onInvalid = new WeakMap(), _FormControl_validationCompleteResolver = new WeakMap(), _FormControl_isValidationPending = new WeakMap(), _FormControl_validationComplete = new WeakMap(), _FormControl_instances = new WeakSet(), _FormControl_formValidationGroup_get = function _FormControl_formValidationGroup_get() {
        const rootNode = this.getRootNode();
        const selector = `${this.localName}[name="${this.getAttribute('name')}"]`;
        return rootNode.querySelectorAll(selector);
    }, _FormControl_shouldShowError = function _FormControl_shouldShowError() {
        if (this.hasAttribute('disabled')) {
            return false;
        }
        const showError = __classPrivateFieldGet(this, _FormControl_forceError, "f") || (__classPrivateFieldGet(this, _FormControl_touched, "f") && !this.validity.valid && !__classPrivateFieldGet(this, _FormControl_focused, "f"));
        /**
         * At the time of writing Firefox doesn't support states
         * TODO: Remove when check for states when fully support is in place
         */
        if (showError && this.internals.states) {
            this.internals.states.add('--show-error');
        }
        else if (this.internals.states) {
            this.internals.states.delete('--show-error');
        }
        return showError;
    }, _FormControl_runValidators = function _FormControl_runValidators(value) {
        const proto = this.constructor;
        const validity = {};
        const validators = proto.validators;
        const asyncValidators = [];
        const hasAsyncValidators = validators.some((validator) => validator.isValid instanceof Promise);
        if (!__classPrivateFieldGet(this, _FormControl_isValidationPending, "f")) {
            __classPrivateFieldSet(this, _FormControl_validationComplete, new Promise(resolve => {
                __classPrivateFieldSet(this, _FormControl_validationCompleteResolver, resolve, "f");
            }), "f");
            __classPrivateFieldSet(this, _FormControl_isValidationPending, true, "f");
        }
        /**
         * If an abort controller exists from a previous validation step
         * notify still-running async validators that we are requesting they
         * discontinue any work.
         */
        if (__classPrivateFieldGet(this, _FormControl_abortController, "f")) {
            __classPrivateFieldGet(this, _FormControl_abortController, "f").abort();
            __classPrivateFieldSet(this, _FormControl_previousAbortController, __classPrivateFieldGet(this, _FormControl_abortController, "f"), "f");
        }
        /**
         * Create a new abort controller and replace the instance reference
         * so we can clean it up for next time
         */
        const abortController = new AbortController();
        __classPrivateFieldSet(this, _FormControl_abortController, abortController, "f");
        let validationMessage = undefined;
        /** Track to see if any validity key has changed */
        let hasChange = false;
        if (!validators.length) {
            return;
        }
        validators.forEach(validator => {
            const key = validator.key || 'customError';
            const isValid = validator.isValid(this, value, abortController.signal);
            const isAsyncValidator = isValid instanceof Promise;
            if (isAsyncValidator) {
                asyncValidators.push(isValid);
                isValid.then(isValidatorValid => {
                    if (isValidatorValid === undefined || isValidatorValid === null) {
                        return;
                    }
                    /** Invert the validity state to correspond to the ValidityState API */
                    validity[key] = !isValidatorValid;
                    validationMessage = __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_getValidatorMessageForValue).call(this, validator, value);
                    __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_setValidityWithOptionalTarget).call(this, validity, validationMessage);
                });
            }
            else {
                /** Invert the validity state to correspond to the ValidityState API */
                validity[key] = !isValid;
                if (this.validity[key] !== !isValid) {
                    hasChange = true;
                }
                // only update the validationMessage for the first invalid scenario
                // so that earlier invalid validators dont get their messages overwritten by later ones
                // in the validators array
                if (!isValid && !validationMessage) {
                    validationMessage = __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_getValidatorMessageForValue).call(this, validator, value);
                }
            }
        });
        /** Once all the async validators have settled, resolve validationComplete */
        Promise.allSettled(asyncValidators)
            .then(() => {
            var _a;
            /** Don't resolve validations if the signal is aborted */
            if (!(abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted)) {
                __classPrivateFieldSet(this, _FormControl_isValidationPending, false, "f");
                (_a = __classPrivateFieldGet(this, _FormControl_validationCompleteResolver, "f")) === null || _a === void 0 ? void 0 : _a.call(this);
            }
        });
        /**
         * If async validators are present:
         * Only run updates when a sync validator has a change. This is to prevent
         * situations where running sync validators can override async validators
         * that are still in progress
         *
         * If async validators are not present, always update validity
         */
        if (hasChange || !hasAsyncValidators) {
            __classPrivateFieldGet(this, _FormControl_instances, "m", _FormControl_setValidityWithOptionalTarget).call(this, validity, validationMessage);
        }
    }, _FormControl_setValidityWithOptionalTarget = function _FormControl_setValidityWithOptionalTarget(validity, validationMessage) {
        if (this.validationTarget) {
            this.internals.setValidity(validity, validationMessage, this.validationTarget);
            __classPrivateFieldSet(this, _FormControl_awaitingValidationTarget, false, "f");
        }
        else {
            this.internals.setValidity(validity, validationMessage);
            if (this.internals.validity.valid) {
                return;
            }
            /**
             * Sets mark the component as awaiting a validation target
             * if the element dispatches an invalid event, the #onInvalid listener
             * will check to see if the validation target has been set since this call
             * has run. This useful in cases like Lit's use of the query
             * decorator for setting the validationTarget or any scenario
             * where the validationTarget isn't available upon construction
             */
            __classPrivateFieldSet(this, _FormControl_awaitingValidationTarget, true, "f");
        }
    }, _FormControl_getValidatorMessageForValue = function _FormControl_getValidatorMessageForValue(validator, value) {
        /** If the validity callback exists and returns, use that as the result */
        if (this.validityCallback) {
            const message = this.validityCallback(validator.key || 'customError');
            if (message) {
                return message;
            }
        }
        if (validator.message instanceof Function) {
            return validator.message(this, value);
        }
        else {
            return validator.message;
        }
    };
    return FormControl;
}
//# sourceMappingURL=FormControlMixin.js.map