{"version":3,"file":"FormControlMixin.js","sourceRoot":"","sources":["FormControlMixin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Constructor, CustomValidityState, FormControlInterface, FormValue, IControlHost, validationMessageCallback, Validator } from './types.js';\n\nexport function FormControlMixin<\n  TBase extends Constructor<HTMLElement & IControlHost> & { observedAttributes?: string [] }\n>(SuperClass: TBase) {\n  class FormControl extends SuperClass {\n    /** Wires up control instances to be form associated */\n    static get formAssociated(): boolean {\n      return true;\n    }\n\n    /**\n     * A list of Validator objects that will be evaluated when a control's form\n     * value is modified or optionally when a given attribute changes.\n     *\n     * When a Validator's callback returns false, the entire form control will\n     * be set to an invalid state.\n     */\n    declare static formControlValidators: Validator[];\n\n     /**\n     * If set to true the control described should be evaluated and validated\n     * as part of a group. Like a radio, if any member of the group's validity\n     * changes the the other members should update as well.\n     */\n    declare static formControlValidationGroup: boolean;\n\n    private static get validators(): Validator[] {\n      return this.formControlValidators || [];\n    }\n\n    /**\n     * Allows the FormControl instance to respond to Validator attributes.\n     * For instance, if a given Validator has a `required` attribute, that\n     * validator will be evaluated whenever the host's required attribute\n     * is updated.\n     */\n     static get observedAttributes(): string[] {\n      const validatorAttributes = this.validators.map((validator) => validator.attribute).flat();\n\n      const observedAttributes = super.observedAttributes || [];\n\n      /** Make sure there are no duplicates inside the attributes list */\n      const attributeSet = new Set([...observedAttributes, ...validatorAttributes]);\n      return [...attributeSet] as string[];\n    }\n\n    /**\n     * Return the validator associated with a given attribute. If no\n     * Validator is associated with the attribute, it will return null.\n     */\n    static getValidator(attribute: string): Validator | null {\n      return this.validators.find((validator) => validator.attribute === attribute) || null;\n    }\n\n    /**\n     * Get all validators that are set to react to a given attribute\n     * @param {string} attribute - The attribute that has changed\n     * @returns {Validator[]}\n     */\n    static getValidators(attribute: string): Validator[] | null {\n      return this.validators.filter(validator => {\n        if (validator.attribute === attribute || validator.attribute?.includes(attribute)) {\n          return true;\n        }\n      });\n    }\n\n    /** The ElementInternals instance for the control. */\n    internals = this.attachInternals();\n\n    /**\n     * Keep track of if the control has focus\n     * @private\n     */\n    #focused = false;\n\n    /**\n     * Exists to control when an error should be displayed\n     * @private\n     */\n    #forceError = false;\n\n    /**\n     * Toggles to true whenever the element has been focused. This property\n     * will reset whenever the control's formResetCallback is called.\n     * @private\n     */\n    #touched = false;\n\n    /** An internal abort controller for cancelling pending async validation */\n    #abortController?: AbortController;\n    #previousAbortController?: AbortController;\n\n    /**\n     * Used for tracking if a validation target has been set to manage focus\n     * when the control's validity is reported\n     */\n    #awaitingValidationTarget = true;\n\n    /** All of the controls within a root with a matching local name and form name */\n    get #formValidationGroup(): NodeListOf<FormControl> {\n      const rootNode = this.getRootNode() as HTMLElement;\n      const selector = `${this.localName}[name=\"${this.getAttribute('name')}\"]`;\n      return rootNode.querySelectorAll<FormControl>(selector);\n    }\n\n    /**\n     * Acts as a cache for the current value so the value can be re-evaluated\n     * whenever an attribute changes or on some other event.\n     */\n    #value: FormValue = '';\n\n    /**\n     * Set this[touched] and this[focused]\n     * to true when the element is focused\n     * @private\n     */\n    #onFocus = (): void => {\n      this.#touched = true;\n      this.#focused = true;\n      this.#shouldShowError();\n    };\n\n    /**\n     * Reset this[focused] on blur\n     * @private\n     */\n    #onBlur = (): void => {\n      this.#focused = false;\n\n      this.#runValidators(this.shouldFormValueUpdate() ? this.#value : '');\n\n      /**\n       * Set forceError to ensure error messages persist until\n       * the value is changed.\n       */\n      if (!this.validity.valid && this.#touched) {\n        this.#forceError = true;\n      }\n      const showError = this.#shouldShowError();\n      if (this.validationMessageCallback) {\n        this.validationMessageCallback(showError ? this.internals.validationMessage : '');\n      }\n    };\n\n    /**\n     * For the show error state on invalid\n     * @private\n     */\n    #onInvalid = (): void => {\n      if (this.#awaitingValidationTarget && this.validationTarget) {\n        this.internals.setValidity(\n          this.validity,\n          this.validationMessage,\n          this.validationTarget\n        );\n        this.#awaitingValidationTarget = false;\n      }\n      this.#touched = true;\n      this.#forceError = true;\n      this.#shouldShowError();\n      this?.validationMessageCallback?.(this.showError ? this.internals.validationMessage : '');\n    };\n\n    /** Return a reference to the control's form */\n    get form(): HTMLFormElement {\n      return this.internals.form;\n    }\n\n    /**\n     * Will return true if it is recommended that the control shows an internal\n     * error. If using this property, it is wise to listen for 'invalid' events\n     * on the element host and call preventDefault on the event. Doing this will\n     * prevent browsers from showing a validation popup.\n     */\n    get showError(): boolean {\n      return this.#shouldShowError();\n    }\n\n    /**\n     * Forward the internals checkValidity method\n     * will return the valid state of the control.\n     */\n    checkValidity(): boolean {\n      return this.internals.checkValidity();\n    }\n\n    /** The element's validity state */\n    get validity(): ValidityState {\n      return this.internals.validity;\n    }\n\n    /**\n     * The validation message shown by a given Validator object. If the control\n     * is in a valid state this should be falsy.\n     */\n    get validationMessage(): string {\n      return this.internals.validationMessage;\n    }\n\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    constructor(...args: any[]) {\n      super(...args);\n      this.addEventListener?.('focus', this.#onFocus);\n      this.addEventListener?.('blur', this.#onBlur);\n      this.addEventListener?.('invalid', this.#onInvalid);\n      this.setValue(null);\n    }\n\n    attributeChangedCallback(name: string, oldValue: string, newValue: string): void {\n      super.attributeChangedCallback?.(name, oldValue, newValue);\n\n      /**\n       * Check to see if a Validator is associated with the changed attribute.\n       * If one exists, call control's validate function which will perform\n       * control validation.\n       */\n      const proto = this.constructor as typeof FormControl;\n      const validators = proto.getValidators(name);\n\n      if (validators?.length && this.validationTarget) {\n        this.setValue(this.#value);\n      }\n    }\n\n    /** PUBLIC LIFECYCLE METHODS */\n\n    /**\n     * Sets the control's form value if the call to `shouldFormValueUpdate`\n     * returns `true`.\n     * @param value {FormValue} - The value to pass to the form\n     */\n    setValue(value: FormValue): void {\n      this.#forceError = false;\n      this.validationMessageCallback?.('');\n      this.#value = value;\n      const valueShouldUpdate = this.shouldFormValueUpdate();\n      const valueToUpdate = valueShouldUpdate ? value : null;\n      this.internals.setFormValue(valueToUpdate as string);\n      this.#runValidators(valueToUpdate);\n      if (this.valueChangedCallback) {\n        this.valueChangedCallback(valueToUpdate);\n      }\n      this.#shouldShowError();\n    }\n\n    /**\n     * This method can be overridden to determine if the control's form value\n     * should be set on a call to `setValue`. An example of when a user might want\n     * to skip this step is when implementing checkbox-like behavior, first checking\n     * to see if `this.checked` is set to a truthy value. By default this returns\n     * `true`.\n     */\n    shouldFormValueUpdate(): boolean {\n      return true;\n    }\n\n    /** Save a reference to the validation complete resolver */\n    #validationCompleteResolver?: (value: void | PromiseLike<void>) => void;\n\n    /** When true validation will be pending */\n    #isValidationPending = false;\n\n    #validationComplete = Promise.resolve();\n\n    /** A promise that will resolve when all pending validations are complete */\n    get validationComplete(): Promise<void> {\n      return new Promise(resolve => resolve(this.#validationComplete));\n    }\n\n    /** DECLARED INSTANCE METHODS AND PROPERTIES*/\n\n    /**\n     * Resets a form control to its initial state\n     */\n    declare resetFormControl: () => void;\n\n    /**\n     * This method is used to override the controls' validity message\n     * for a given Validator key. This has the highest level of priority when\n     * setting a validationMessage, so use this method wisely.\n     *\n     * The returned value will be used as the validationMessage for the given key.\n     * @param validationKey {string} - The key that has returned invalid\n     */\n    declare validityCallback: (validationKey: string) => string | void;\n\n     /**\n      * Called when the control's validationMessage should be changed\n      * @param message { string } - The new validation message\n      */\n    declare validationMessageCallback: (message: string) => void;\n\n    /**\n     * A callback for when the controls' form value changes. The value\n     * passed to this function should not be confused with the control's\n     * value property, this is the value that will appear on the form.\n     *\n     * In cases where `checked` did not exist on the control's prototype\n     * upon initialization, this value and the value property will be identical;\n     * in cases where `checked` is present upon initialization, this will be\n     * effectively `this.checked && this.value`.\n     */\n    declare valueChangedCallback: (value: FormValue) => void;\n\n    /**\n     * The element that will receive focus when the control's validity\n     * state is reported either by a form submission or via API\n     *\n     * We use declare since this is optional and we don't particularly\n     * care how the consuming component implements this (as a field, member\n     * or getter/setter)\n     */\n    declare validationTarget: HTMLElement | null;\n\n    /** PRIVATE LIFECYCLE METHODS */\n\n    /**\n     * Check to see if an error should be shown. This method will also\n     * update the internals state object with the --show-error state\n     * if necessary.\n     * @private\n     */\n    #shouldShowError(): boolean {\n      if (this.hasAttribute('disabled')) {\n        return false;\n      }\n\n      const showError = this.#forceError || (this.#touched && !this.validity.valid && !this.#focused);\n\n      /**\n       * At the time of writing Firefox doesn't support states\n       * TODO: Remove when check for states when fully support is in place\n       */\n      if (showError && this.internals.states) {\n        this.internals.states.add('--show-error');\n      } else if (this.internals.states) {\n        this.internals.states.delete('--show-error');\n      }\n\n      return showError;\n    }\n\n    #runValidators(value: FormValue): void {\n      const proto = this.constructor as typeof FormControl;\n      const validity: CustomValidityState = {};\n      const validators = proto.validators;\n      const asyncValidators: Promise<boolean|void>[] = [];\n      const hasAsyncValidators = validators.some((validator) => validator.isValid instanceof Promise)\n\n      if (!this.#isValidationPending) {\n        this.#validationComplete = new Promise(resolve => {\n          this.#validationCompleteResolver = resolve\n        });\n        this.#isValidationPending = true;\n      }\n\n      /**\n       * If an abort controller exists from a previous validation step\n       * notify still-running async validators that we are requesting they\n       * discontinue any work.\n       */\n      if (this.#abortController) {\n        this.#abortController.abort();\n        this.#previousAbortController = this.#abortController;\n      }\n\n      /**\n       * Create a new abort controller and replace the instance reference\n       * so we can clean it up for next time\n       */\n      const abortController = new AbortController();\n      this.#abortController = abortController;\n      let validationMessage: string | undefined = undefined;\n\n      /** Track to see if any validity key has changed */\n      let hasChange = false;\n\n      if (!validators.length) {\n        return;\n      }\n\n      validators.forEach(validator => {\n        const key = validator.key || 'customError';\n        const isValid = validator.isValid(this, value, abortController.signal);\n        const isAsyncValidator = isValid instanceof Promise;\n\n        if (isAsyncValidator) {\n          asyncValidators.push(isValid);\n\n          isValid.then(isValidatorValid => {\n            if (isValidatorValid === undefined || isValidatorValid === null) {\n              return;\n            }\n            /** Invert the validity state to correspond to the ValidityState API */\n            validity[key] = !isValidatorValid;\n\n            validationMessage = this.#getValidatorMessageForValue(validator, value);\n            this.#setValidityWithOptionalTarget(validity, validationMessage);\n          });\n        } else {\n          /** Invert the validity state to correspond to the ValidityState API */\n          validity[key] = !isValid;\n\n          if (this.validity[key] !== !isValid) {\n            hasChange = true;\n          }\n\n          // only update the validationMessage for the first invalid scenario\n          // so that earlier invalid validators dont get their messages overwritten by later ones\n          // in the validators array\n          if (!isValid && !validationMessage) {\n            validationMessage = this.#getValidatorMessageForValue(validator, value);\n          }\n        }\n      });\n\n      /** Once all the async validators have settled, resolve validationComplete */\n      Promise.allSettled(asyncValidators)\n        .then(() => {\n          /** Don't resolve validations if the signal is aborted */\n          if (!abortController?.signal.aborted) {\n            this.#isValidationPending = false;\n            this.#validationCompleteResolver?.();\n          }\n        });\n\n      /**\n       * If async validators are present:\n       * Only run updates when a sync validator has a change. This is to prevent\n       * situations where running sync validators can override async validators\n       * that are still in progress\n       *\n       * If async validators are not present, always update validity\n       */\n      if (hasChange || !hasAsyncValidators) {\n        this.#setValidityWithOptionalTarget(validity, validationMessage);\n      }\n    }\n\n    /**\n     * If the validationTarget is not set, the user can decide how they would\n     * prefer to handle focus when the field is validated.\n     */\n    #setValidityWithOptionalTarget(validity: Partial<ValidityState>, validationMessage: string|undefined): void {\n      if (this.validationTarget) {\n        this.internals.setValidity(validity, validationMessage, this.validationTarget);\n        this.#awaitingValidationTarget = false;\n      } else {\n        this.internals.setValidity(validity, validationMessage);\n\n        if (this.internals.validity.valid) {\n          return;\n        }\n\n        /**\n         * Sets mark the component as awaiting a validation target\n         * if the element dispatches an invalid event, the #onInvalid listener\n         * will check to see if the validation target has been set since this call\n         * has run. This useful in cases like Lit's use of the query\n         * decorator for setting the validationTarget or any scenario\n         * where the validationTarget isn't available upon construction\n         */\n        this.#awaitingValidationTarget = true;\n      }\n    }\n\n    /** Process the validator message attribute */\n    #getValidatorMessageForValue(validator: Validator, value: FormValue): string {\n      /** If the validity callback exists and returns, use that as the result */\n      if (this.validityCallback) {\n        const message = this.validityCallback(validator.key || 'customError');\n\n        if (message) {\n          return message;\n        }\n      }\n\n      if (validator.message instanceof Function) {\n        return (validator.message as validationMessageCallback)(this, value);\n      } else {\n        return validator.message as string;\n      }\n    }\n\n     /** Reset control state when the form is reset */\n    formResetCallback() {\n      this.#touched = false;\n      this.#forceError = false;\n      this.#shouldShowError();\n      this.resetFormControl?.();\n\n      this.validationMessageCallback?.(\n        this.#shouldShowError() ? this.validationMessage : ''\n      );\n    }\n  }\n\n  return FormControl as Constructor<FormControlInterface> & TBase;\n}\n"]}